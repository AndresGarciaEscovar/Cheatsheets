%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "Make" Cheatsheet
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\textquotedblleft Make\textquotedblright\ Cheatsheet}

%///////////////////////////////////////////////////////////////////////////////
% General Structure
%///////////////////////////////////////////////////////////////////////////////
\subsection{General Structure}

The general structure of a \textquotedblleft make\textquotedblright\ file is as
follows:
\begin{minted}[frame=single]{bash}
target: pre-requisites
    command
    command
    .
    .
    .
    command
\end{minted}
\begin{itemize}
    \item target: is the name of the file generated by the \textquotedblleft
    make\textquotedblright\ file.
    \item pre-requisites: are the files used to generate the target. These 
    pre-requisites are also called\linebreak dependencies. Dependencies will be 
    re-compiled if they have been modified since the last time the target was
    generated.
    \item command: is the command used to generate the target. There can be
    multiple commands per target.
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Using a "makefile".
%///////////////////////////////////////////////////////////////////////////////
\subsection{Using a \textquotedblleft makefile\textquotedblright}
\begin{itemize}
    \item To run a simple \textquotedblleft makefile\textquotedblright\ use the
    file structure shown below:
    \begin{minted}[frame=single]{bash}
<root>
|___makefile
|___main.c
    \end{minted}
    The content of the \textquotedblleft makefile\textquotedblright\ is as
    follows:
    \begin{minted}[frame=single]{bash}
all: main.c
    gcc -o main main.c
    \end{minted}
    Use the file to compile the \textquotedblleft main.c\textquotedblright\ 
    file:
    \begin{minted}[frame=single]{bash}
$ make
    \end{minted}
    \item To include multiple commands add more targets:
    \begin{minted}[frame=single]{bash}
default: main.c
    gcc -o main main.c

clean:
    rm main
    \end{minted}
    When running a \textquotedblleft makefile\textquotedblright\ with multiple
    targets, the first target is the default target. To run a specific target
    use:
    \begin{minted}[frame=single]{bash}
$ make clean
    \end{minted}
    \newpage
    \item To include multiple pre-requisites add them to the target:
    \begin{minted}[frame=single]{bash}
default: main.c main.h
    gcc -o main main.c
    \end{minted}
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Using multiple dependencies.
%///////////////////////////////////////////////////////////////////////////////
\subsection{Using multiple dependencies}
\begin{itemize}
    \item The following \textquotedblleft makefile\textquotedblright\ runs the
    three targets to build a program:
    \begin{minted}[frame=single]{bash}
blah: blah.o
    gcc blah.o -o blah

blah.o: blah.c
    gcc -c blah.c -o blah.o

blah.c:
    echo "int main() { return 0; }" > blah.c
    \end{minted}
    \subsubsection{How it works}
    \begin{enumerate}
        \item Make selects the target \textquotedblleft blah\textquotedblright,
        because it is the first target in the \textquotedblleft 
        makefile\textquotedblright, i.e., the default target.
        \item \textquotedblleft blah\textquotedblright\ depends on 
        \textquotedblleft blah.o\textquotedblright, so make looks for the
        target \textquotedblleft blah.o\textquotedblright.
        \item \textquotedblleft blah.o\textquotedblright\ depends on
        \textquotedblleft blah.c\textquotedblright, so make looks for the
        target \textquotedblleft blah.c\textquotedblright.
        \item \textquotedblleft blah.c\textquotedblright\ is a phony target,
        so make runs the command associated with it.
        \item Make then goes back to \textquotedblleft blah.o\textquotedblright,
        which is now available, and runs the command associated with it.
        \item Make then goes back to \textquotedblleft blah\textquotedblright,
        which is now available, and runs the command associated with it.
    \end{enumerate}
    \item If \textbf{all} targets need to be run, use the \textquotedblleft
    all\textquotedblright\ target:
    \begin{minted}[frame=single]{bash}
all: one two three

one:
    echo "one"

two:
    echo "two"

three:
    echo "three"

clean:
    echo "clean"
    \end{minted}
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Variables
%///////////////////////////////////////////////////////////////////////////////
\subsection{Variables}

Variables can only be strings. 
\begin{itemize}
    \item To define a variable use $:=$ or $=$; the difference is that $:=$ is
    evaluated at the time of definition, while $=$ is evaluated at the time of
    use. For example:
    \begin{minted}[frame=single]{bash}
x := $(shell date)
tt:
    echo $(x)
    sleep 2
    echo $(x)
    \end{minted}
    will yield:
    \begin{minted}[frame=single]{bash}
$ make tt
sex 22 jan 2021 14:56:08 -03
sex 22 jan 2021 14:56:08 -03
    \end{minted}
    whereas:
    \begin{minted}[frame=single]{bash}
x = $(shell date)
tt:
echo $(x)
sleep 2
echo $(x)
    \end{minted}
    will yield:
    \begin{minted}[frame=single]{bash}
$ make tt
sex 22 jan 2021 14:56:08 -03
sex 22 jan 2021 14:56:10 -03
    \end{minted}
    Notice that the latter yields different results because the variable is 
    evaluated at the time of use, not at the time of definition.
    \item Variables can be referenced using \textquotedblleft
    \$()\textquotedblright\ or \textquotedblleft \$\{\}\textquotedblright. For
    example:
    \begin{minted}[frame=single]{bash}
x = 1
default:
    echo ${x}
    echo $(x)
    \end{minted}
    \item The \textquotedblleft \$@\textquotedblright\ character is a special
    character that represents the target. For example:
    \begin{minted}[frame=single]{bash}
all: one two

one two:
    echo $@

# Is the same as:
# one:
#     echo one
# two:
#     echo two
    \end{minted}
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Use of Wildcards.
%///////////////////////////////////////////////////////////////////////////////
\subsection{Use of Wildcards}

\begin{itemize}
    \item Wildcards can be used to select multiple files that match a pattern.
    \item There are three types of wildcards:
    \begin{enumerate}
        \item \textquotedblleft *\textquotedblright\ matches any number of
        characters, including none.
        \item \textquotedblleft \%\textquotedblright\ matches any single
        character, including none.
        \begin{itemize}
            \item This character can be used in \textquotedblleft matching
            mode\textquotedblright , i.e., matches one or more characters in
            a string. This is called the \textquotedblleft stem
            \textquotedblright.
            \item This character can be used in \textquotedblleft replacing
            mode\textquotedblright , i.e., replaces the stem with the\linebreak
            \textquotedblleft replacement\textquotedblright string.
            \item Often used in rule definitions and some specific functions.
        \end{itemize}
    \end{enumerate}
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Implicit Rules
%///////////////////////////////////////////////////////////////////////////////
\subsection{Implict Rules}
There are some implicit rules when using \textquotedblleft makefiles 
\textquotedblright:
\begin{itemize}
    \item Compiling a C program: \mintinline{text}|n.o| is made automatically
    from \mintinline{text}|n.c| with a command of the form:
    \begin{minted}[frame=single]{bash}
$(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@
    \end{minted}
    \item Compiling a C++ program: \mintinline{text}|n.o| is made automatically
    from \mintinline{text}|n.cc| or \mintinline{text}|n.ccp| with a command of
    the form:
    \begin{minted}[frame=single]{bash}
$(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@
    \end{minted}
    \item Linking a single object file: \mintinline{text}|n| is made
    automatically from \mintinline{text}|n.o| by running the command:
    \begin{minted}[frame=single]{bash}
$(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@
    \end{minted}
    where:
    \begin{itemize}
        \item \mintinline{text}|CC|: Program for compiling C programs; default
        is \mintinline{text}|cc|.
        \item \mintinline{text}|CXX|: Program for compiling C++ programs;
        default is \mintinline{text}|g++|.
        \item \mintinline{text}|CFLAGS|: Extra flags to give to the C compiler.
        \item \mintinline{text}|CXXFLAGS|: Extra flags to give to the C++
        compiler.
        \item \mintinline{text}|CXXFLAGS|: Extra flags to give to the C++
        preprocessor.
        \item \mintinline{text}|LDFLAGS|: Extra flags to give to compilers when
        they are supposed to invoke the linker. For example,
        \mintinline{text}|-L|. 
    \end{itemize}
\end{itemize}

%///////////////////////////////////////////////////////////////////////////////
% Important Comments.
%///////////////////////////////////////////////////////////////////////////////
\subsection{Important Comments}
\begin{itemize}
    \item When indenting, use tabs, not spaces. Indenting in \textquotedblleft
    make\textquotedblright\ is done with tabs, not spaces, i.e., tabs are
    mandatory.
\end{itemize}
